# Check Environment Variable Encryption

Encrypting environment variables of an AWS Lambda function using Terraform involves several steps within Terraform's resource blocks. First, you create a Key Management Service (KMS) key using the aws_kms_key resource block, specifying details like description, key rotation, and deletion window. This key will be used to encrypt and decrypt the environment variables. Next, in the aws_lambda_function resource block that defines your Lambda function, you specify the kms_key_arn parameter with the ARN of the KMS key created earlier. Within the environment block of the Lambda function resource, you define the environment variables you want to encrypt, setting their values as plaintext. When Terraform deploys these resources, it encrypts the specified environment variables using the specified KMS key.


In this configuration:
kms_key_arn specifies the ARN of the aws_kms_key created in AWS Console.
You need to make sure that the kms_key_arn attribute is provided a valid string value in the aws_lambda_function resource block. If you do, the Policy will give you passing checks else failing checks.

## Policy Details:

-   **Policy Name:** Check Environment Variable Encryption
-   **Check Description:** This policy ensures that if environment variables are used in a Lambda function, they should be encrypted.
-   **Policy Category:** AWS Lambda Best Practices

### Policy Validation Testing Instructions

For testing this policy you will need to:

-   Make sure you have `cloud-scanner` installed on the machine
-   Properly authenticate with AWS

1. **Set up for the Lambda Function:**

    a. Create a `lambda_function.py` file with the following code:

    ```python
    def lambda_handler(event, context):
        return {
            'statusCode': 200,
            'body': 'Hello, world!'
        }
    ```

    b. Store the above python file in a zip file `lambda-code.zip`
2. **Create an IAM Role for Lambda:**
    ```bash
    aws iam create-role \
    --role-name <RoleName> \
    --assume-role-policy-document '{
        "Version": "2012-10-17",
        "Statement": [
        {
            "Action": "sts:AssumeRole",
            "Principal": {
            "Service": "lambda.amazonaws.com"
            },
            "Effect": "Allow",
            "Sid": ""
        }
        ]
    }'
    ```
3. **Create an IAM Policy for Lambda:**
    ```bash
    aws iam create-policy \
    --policy-name aws_iam_policy_for_terraform_aws_lambda_role \
    --policy-document '{
        "Version": "2012-10-17",
        "Statement": [
        {
            "Action": [
            "logs:CreateLogGroup",
            "logs:CreateLogStream",
            "logs:PutLogEvents"
            ],
            "Resource": "arn:aws:logs:*:*:*",
            "Effect": "Allow"
        }
        ]
    }'
    ```
4. **Attach the Policy to the IAM Role:**

    a. Retrieve the ARN of the created policy:
    ```bash
    aws iam list-policies --query "Policies[?PolicyName=='aws_iam_policy_for_terraform_aws_lambda_role'].Arn" --output text
    ```
    b. Use the ARN to attach the policy to the IAM role:
    ```bash
    aws iam attach-role-policy \
    --role-name Spacelift_Test_Lambda_Function_Role \
    --policy-arn <POLICY_ARN>
    ```
5. **Create Lambda Functions:**

    Good Lambda Function
    ```bash
    aws lambda create-function \
    --function-name GoodLambdaFunction \
    --runtime python3.8 \
    --role arn:aws:iam::<ACCOUNT_ID>:role/<RoleName>> \
    --handler index.lambda_handler \
    --zip-file fileb://lambda_function.zip \
    --environment Variables="{SECRET_KEY=Terraform key}" \
    --kms-key-arn arn:aws:kms:us-west-2:844333597536:key/<key-id> \
    ```

    NOTE - This step will fail if you have applied the policy as a result of Admission Controller.
    
    Bad Lambda Function
    ```bash
     aws lambda create-function \
     --function-name BadLambdaFunction \
     --runtime python2.7 \
     --role arn:aws:iam::<ACCOUNT_ID>:role/<RoleName>> \
     --handler index.lambda_handler \
     --zip-file fileb://lambda_function.zip \
     --environment Variables="{SECRET_KEY=Terraform key}" \
    ```


6. **Get the Payloads:**

    Good Payload
    ```bash
    aws cloudcontrol get-resource  --type-name AWS::Lambda::Function --profile devtest-sso --identifier GoodLambdaFunction | jq '.ResourceDescription.Properties |= fromjson'
    ```
    Bad Payload
    ```bash
    aws cloudcontrol get-resource  --type-name AWS::Lambda::Function --profile devtest-sso --identifier BadLambdaFunction | jq '.ResourceDescription.Properties |= fromjson'
    ```


## Test the Policy with Cloud Scanner:

a. **Apply the Policy after making the appropriate AWS resources:**

```
kubectl apply -f ./check-env-var-encryption.yaml
```


b. **Check the Report Generated by Cloud Scanner:**

```
kubectl get clusterpolicyreport
```


```
NAME                                                              KIND             NAME                             PASS   FAIL   WARN   ERROR   SKIP      AGE
65dce8b586794a7ec90e54d03f32a339e1a7cfbfffa115f732d8a78382c3f5f   LambdaFunction   GoodLambdaFunction                 1      0      0      0       0      7m54s
65dce8b586794a7ec90e54d03f32a339e1a7cfbfffa115f732d8a78382c3asd   LambdaFunction   BadLambdaFunction                  0      1      0      0       0      7m54s

```

---